/*
 * Copyright 2025 shinhyo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.shinhyo.signinwithapple

import android.app.Activity
import android.content.Context
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.os.ResultReceiver
import io.github.shinhyo.signinwithapple.model.AppleSignInResult
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.suspendCancellableCoroutine
import java.util.concurrent.CancellationException
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

/**
 * Apple Sign-In Service
 *
 * This is the Apple ID authentication service used by external modules.
 * It uses a WebView to perform Apple OAuth authentication and safely delivers the result via ResultReceiver.
 *
 * Usage:
 * - Simply call the signIn(context, nonce, callback) method with a secure nonce.
 * - No need to handle onActivityResult separately.
 * - Works independently of the Activity lifecycle.
 * - Always generate a unique, secure nonce for each sign-in attempt.
 */
object SignInWithApple {

    private var serviceId: String? = null
    private var redirectUri: String? = null

    /**
     * Initializes the Apple Sign-In library.
     *
     * @param serviceId The Apple Service ID configured in Apple Developer Console
     * @param redirectUri The redirect URI registered with Apple
     */
    fun init(serviceId: String, redirectUri: String) {
        this.serviceId = serviceId
        this.redirectUri = redirectUri
    }

    /**
     * Gets the redirect URI (for backward compatibility)
     */
    internal fun getRedirectUri(): String =
        redirectUri ?: throw IllegalStateException("SignInWithApple not initialized")

    /**
     * Starts Apple Sign-In.
     *
     * @param context Context (Activity or Application Context)
     * @param nonce Secure, random nonce for replay attack prevention (must be generated by the caller for each sign-in attempt)
     * @param callback Login result callback (on success: AppleSignInResult containing identity token, on failure: Exception)
     */
    fun signIn(
        context: Context,
        nonce: String,
        callback: (Result<AppleSignInResult>) -> Unit,
    ) {
        try {
            val currentServiceId =
                serviceId ?: throw IllegalStateException("SignInWithApple not initialized")
            val currentRedirectUri =
                redirectUri ?: throw IllegalStateException("SignInWithApple not initialized")

            // Create ResultReceiver
            val resultReceiver = createResultReceiver(callback)

            // Start WebView Activity with configuration
            val intent = AppleSignInWebViewActivity.createIntent(
                context = context,
                clientId = currentServiceId,
                redirectUri = currentRedirectUri,
                nonce = nonce,
                resultReceiver = resultReceiver,
            )
            context.startActivity(intent)
        } catch (e: Exception) {
            callback(Result.failure(e))
        }
    }

    /**
     * Creates a ResultReceiver.
     */
    private fun createResultReceiver(
        callback: (Result<AppleSignInResult>) -> Unit,
    ): ResultReceiver = object : ResultReceiver(Handler(Looper.getMainLooper())) {
        override fun onReceiveResult(resultCode: Int, resultData: Bundle?) {
            try {
                when (resultCode) {
                    Activity.RESULT_OK -> {
                        handleSuccessResult(resultData, callback)
                    }

                    Activity.RESULT_CANCELED -> {
                        callback(Result.failure(CancellationException("User canceled the login")))
                    }

                    else -> {
                        callback(Result.failure(Exception("Unknown result code: $resultCode")))
                    }
                }
            } catch (e: Exception) {
                callback(Result.failure(e))
            }
        }
    }

    /**
     * Handles the success result.
     */
    private fun handleSuccessResult(
        resultData: Bundle?,
        callback: (Result<AppleSignInResult>) -> Unit,
    ) {
        try {
            val bundle = resultData ?: throw Exception("No result data")

            val idToken = bundle.getString("id_token")
            val error = bundle.getString("error")

            // Handle result based on presence of idToken or error
            when {
                !idToken.isNullOrEmpty() -> {
                    val credential = AppleSignInResult(identityToken = idToken)
                    callback(Result.success(credential))
                }

                !error.isNullOrEmpty() -> {
                    callback(Result.failure(Exception("Apple login error: $error")))
                }

                else -> {
                    callback(Result.failure(Exception("Unknown Apple login result")))
                }
            }
        } catch (e: Exception) {
            callback(Result.failure(e))
        }
    }
}

/**
 * Extension function that enables Apple Sign-In to be used as a Flow.
 */
fun SignInWithApple.flow(context: Context, nonce: String): Flow<AppleSignInResult> = flow {
    suspendCancellableCoroutine { cont ->
        SignInWithApple.signIn(context, nonce) { result ->
            result
                .onSuccess { appleSignInResult ->
                    cont.resume(appleSignInResult)
                }
                .onFailure { exception ->
                    cont.resumeWithException(exception)
                }
        }
    }.let { appleSignInResult ->
        emit(appleSignInResult)
    }
}