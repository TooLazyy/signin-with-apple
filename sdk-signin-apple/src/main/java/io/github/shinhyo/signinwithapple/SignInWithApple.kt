/*
 * MIT License
 *
 * Copyright (c) 2025 shinhyo
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package io.github.shinhyo.signinwithapple

import android.app.Activity
import android.content.Context
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.os.ResultReceiver
import io.github.shinhyo.signinwithapple.model.AppleSignInResult
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.suspendCancellableCoroutine
import java.util.concurrent.CancellationException
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

/**
 * Apple Sign-In Service
 *
 * This is the Apple ID authentication service used by external modules.
 * It uses a WebView to perform Apple OAuth authentication and safely delivers the result via ResultReceiver.
 *
 * Usage:
 * - Simply call the signIn(context, nonce, callback) method with a secure nonce.
 * - No need to handle onActivityResult separately.
 * - Works independently of the Activity lifecycle.
 * - Always generate a unique, secure nonce for each sign-in attempt.
 */
object SignInWithApple {

    private var serviceId: String? = null
    private var redirectUri: String? = null

    /**
     * Cancellable handle for Apple Sign-In operations
     */
    interface CancellableSignIn {
        fun cancel()
    }

    private val activeSignIns = mutableMapOf<ResultReceiver, CancellableSignIn>()

    /**
     * Initializes the Apple Sign-In library.
     *
     * @param serviceId The Apple Service ID configured in Apple Developer Console
     * @param redirectUri The redirect URI registered with Apple
     * @throws IllegalArgumentException if serviceId or redirectUri is empty
     */
    fun init(serviceId: String, redirectUri: String) {
        require(serviceId.isNotEmpty()) { "Service ID cannot be empty" }
        require(redirectUri.isNotEmpty()) { "Redirect URI cannot be empty" }

        this.serviceId = serviceId
        this.redirectUri = redirectUri
    }

    /**
     * Gets the redirect URI (for backward compatibility)
     */
    internal fun getRedirectUri(): String {
        return if (redirectUri.isNullOrEmpty()) {
            throw IllegalStateException("SignInWithApple not initialized")
        } else {
            redirectUri!!
        }
    }

    /**
     * Starts Apple Sign-In.
     *
     * @param context Context (Activity or Application Context)
     * @param nonce Secure, random nonce for replay attack prevention (must be generated by the caller for each sign-in attempt)
     * @param callback Login result callback (on success: AppleSignInResult containing identity token, on failure: Exception)
     */
    fun signIn(
        context: Context,
        nonce: String,
        callback: (Result<AppleSignInResult>) -> Unit,
    ) {
        signInCancellable(context, nonce, callback)
    }

    /**
     * Starts Apple Sign-In with cancellation support.
     *
     * @param context Context (Activity or Application Context)
     * @param nonce Secure, random nonce for replay attack prevention (must be generated by the caller for each sign-in attempt)
     * @param callback Login result callback (on success: AppleSignInResult containing identity token, on failure: Exception)
     * @return CancellableSignIn handle that can be used to cancel the operation
     */
    internal fun signInCancellable(
        context: Context,
        nonce: String,
        callback: (Result<AppleSignInResult>) -> Unit,
    ): CancellableSignIn {
        return try {
            val currentServiceId =
                serviceId ?: throw IllegalStateException("SignInWithApple not initialized")
            val currentRedirectUri =
                redirectUri ?: throw IllegalStateException("SignInWithApple not initialized")

            // Create ResultReceiver
            val resultReceiver = createResultReceiver(callback)

            val cancellableSignIn = object : CancellableSignIn {
                override fun cancel() {
                    activeSignIns.remove(resultReceiver)
                    // Note: We can't directly cancel the WebView activity once started,
                    // but we can prevent the callback from being invoked
                }
            }

            activeSignIns[resultReceiver] = cancellableSignIn

            // Start WebView Activity with configuration
            val intent = AppleSignInWebViewActivity.createIntent(
                context = context,
                clientId = currentServiceId,
                redirectUri = currentRedirectUri,
                nonce = nonce,
                resultReceiver = resultReceiver,
            )
            context.startActivity(intent)

            cancellableSignIn
        } catch (e: Exception) {
            callback(Result.failure(e))
            object : CancellableSignIn {
                override fun cancel() {
                    // No-op for failed sign-in attempts
                }
            }
        }
    }

    /**
     * Creates a ResultReceiver.
     */
    private fun createResultReceiver(
        callback: (Result<AppleSignInResult>) -> Unit,
    ): ResultReceiver = object : ResultReceiver(Handler(Looper.getMainLooper())) {
        override fun onReceiveResult(resultCode: Int, resultData: Bundle?) {
            try {
                // Check if this sign-in operation is still active
                if (!activeSignIns.containsKey(this)) {
                    // Operation was cancelled, don't invoke callback
                    return
                }

                // Remove from active sign-ins
                activeSignIns.remove(this)

                when (resultCode) {
                    Activity.RESULT_OK -> {
                        handleSuccessResult(resultData, callback)
                    }

                    Activity.RESULT_CANCELED -> {
                        callback(Result.failure(CancellationException("User canceled the login")))
                    }

                    else -> {
                        callback(Result.failure(Exception("Unknown result code: $resultCode")))
                    }
                }
            } catch (e: Exception) {
                callback(Result.failure(e))
            }
        }
    }

    /**
     * Handles the success result.
     */
    private fun handleSuccessResult(
        resultData: Bundle?,
        callback: (Result<AppleSignInResult>) -> Unit,
    ) {
        try {
            val bundle = resultData ?: throw Exception("No result data")

            val idToken = bundle.getString("id_token")
            val error = bundle.getString("error")

            // Handle result based on presence of idToken or error
            when {
                !idToken.isNullOrEmpty() -> {
                    val credential = AppleSignInResult(identityToken = idToken)
                    callback(Result.success(credential))
                }

                !error.isNullOrEmpty() -> {
                    callback(Result.failure(Exception("Apple login error: $error")))
                }

                else -> {
                    callback(Result.failure(Exception("Unknown Apple login result")))
                }
            }
        } catch (e: Exception) {
            callback(Result.failure(e))
        }
    }
}

/**
 * Extension function that enables Apple Sign-In to be used as a Flow.
 */
fun SignInWithApple.flow(context: Context, nonce: String): Flow<AppleSignInResult> = flow {
    val appleSignInResult = suspendCancellableCoroutine { cont ->
        val signInRequest = SignInWithApple.signInCancellable(context, nonce) { result ->
            result
                .onSuccess { appleSignInResult ->
                    cont.resume(appleSignInResult)
                }
                .onFailure { exception ->
                    cont.resumeWithException(exception)
                }
        }

        // Register cancellation handler to cancel the sign-in request
        cont.invokeOnCancellation {
            signInRequest.cancel()
        }
    }
    emit(appleSignInResult)
}